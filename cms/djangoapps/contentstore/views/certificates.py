"""
Certificates Data Model:

course.certificates: {
    'certificates': [
        {
            'version': 1, // data contract version
            'id': 12345, // autogenerated identifier
            'name': 'Certificate 1',
            'description': 'Certificate 1 Description',
            'course_title': 'course title',
            'course_description': 'course_description', //short course description, not required
            'organizations': [
                {'short_name': 'ORG1_SHORT_NAME'},
                {'short_name': 'ORG2_SHORT_NAME'},
            ],
            'signatories': [
                {
                    'id': 24680, // autogenerated identifier
                    'name': 'Dr. Bob Smith',
                    'title': 'Dean of the College',
                    'organization': 'Awesome College'
                }
            ],
            'show_grade': false, // whether to display student's grade or not
            'honor_code_disclaimer': "It's just a honor code certificate, no verification passed" // used for honor code certificates only, not required
        }
    ]
}
"""
import re
import json
import urllib

from django.conf import settings
from django.contrib.auth.decorators import login_required
from django.views.decorators.csrf import ensure_csrf_cookie
from django.http import HttpResponse
from django.utils.translation import ugettext as _
from django.views.decorators.http import require_http_methods

from rest_framework import serializers

from contentstore.utils import reverse_course_url
from edxmako.shortcuts import render_to_response
from opaque_keys.edx.keys import CourseKey, AssetKey
from eventtracking import tracker
from student.auth import has_studio_write_access
from student.roles import GlobalStaff
from util import organizations_helpers
from util.db import generate_int_id, MYSQL_MAX_INT
from util.json_request import JsonResponse
from xmodule.modulestore import EdxJSONEncoder
from xmodule.modulestore.django import modulestore
from contentstore.views.assets import delete_asset
from contentstore.views.exception import AssetNotFoundException
from django.core.exceptions import PermissionDenied
from course_modes.models import CourseMode
from contentstore.utils import get_lms_link_for_certificate_web_view


CERTIFICATE_SCHEMA_VERSION = 'lek-1'
CERTIFICATE_MINIMUM_ID = 100


def _get_course_and_check_access(course_key, user, depth=0):
    """
    Internal method used to calculate and return the locator and
    course module for the view functions in this file.
    """
    if not has_studio_write_access(user, course_key):
        raise PermissionDenied()
    course_module = modulestore().get_course(course_key, depth=depth)
    return course_module


def _delete_asset(course_key, asset_key_string):
    """
    Internal method used to create asset key from string and
    remove asset by calling delete_asset method of assets module.
    """
    if asset_key_string:
        # remove first slash in asset path
        # otherwise it generates InvalidKeyError in case of split modulestore
        if '/' == asset_key_string[0]:
            asset_key_string = asset_key_string[1:]
        asset_key = AssetKey.from_string(asset_key_string)
        try:
            delete_asset(course_key, asset_key)
        # If the asset was not found, it doesn't have to be deleted...
        except AssetNotFoundException:
            pass


def get_default_certificate_organizations(course_key):
    """
    Get short names of organizations to be displayed on the certificate by default.
    This list usually consists of platform organization and organization used in
    course id.
    """
    course_organizations = organizations_helpers.get_course_organizations(course_key)
    platform_organization = organizations_helpers.get_organization_by_short_name(
        settings.CERTIFICATE_DEFAULT_ORGANIZATION
    )
    organizations = [org['short_name'] for org in course_organizations]
    if platform_organization and platform_organization['short_name'] not in organizations:
        organizations.insert(0, platform_organization['short_name'])
    return [{'short_name': org} for org in organizations]


def get_serializable_organizations_list():
    """
    Get list of all organization prepared for usage by certificate editor.
    Each organization item includes short name, long name and logo path.
    """
    def _get_logo_url(logo):
        if logo:
            return u"//{base}{media_url}{url}".format(
                base=settings.LMS_BASE,
                media_url=settings.LMS_MEDIA_URL,
                url=logo.url
            )
        return ''

    organizations = organizations_helpers.get_organizations()
    return [{
        'short_name': org['short_name'],
        'long_name': org['name'],
        'logo': _get_logo_url(org['logo'])
    } for org in organizations]


# Certificates Exceptions
class CertificateException(Exception):
    """
    Base exception for Certificates workflows
    """
    pass


class CertificateValidationError(CertificateException):
    """
    An exception raised when certificate information is invalid.
    """
    pass


class SignatorySerializer(serializers.Serializer):
    """
    Serializer for serialization and validation of Signatory objects
    """
    id = serializers.IntegerField(required=False)
    name = serializers.CharField(required=False, allow_blank=True)
    title = serializers.CharField(required=False, allow_blank=True)
    organization = serializers.CharField(required=False, allow_blank=True)
    signature_image_path = serializers.CharField(required=False, allow_blank=True, default='')

    # required for per-signatory updates, null is allowed for new signatories only
    certificate = serializers.IntegerField(required=False, allow_null=True)


class OrganizationSerializer(serializers.Serializer):
    """
    Serializer for serialization and validation of certificate organizations

    Currently only short name is stored in certificate to map it to existing
    Organization model.
    Existence is not validated to allow editing of imported courses with
    not-yet-created organizations linked to certificates.
    """
    short_name = serializers.CharField(required=True, allow_blank=False)

    def validate_short_name(self, value):
        """
        Validates organization short_name, similar to course creation validators
        """
        if settings.FEATURES.get('ALLOW_UNICODE_COURSE_ID'):
            if value != re.sub(r'\s+', '', value, flags=re.UNICODE):
                raise serializers.ValidationError(_('This field should not contain any spaces.'))
        else:
            if value != urllib.quote(value) or any(symbol in value for symbol in "!'()*"):
                raise serializers.ValidationError(
                    _('This field should not contain any non-latin letters, special characters or spaces.')
                )
        return value


class CertificateSerializer(serializers.Serializer):
    """
    Serializer for serialization and validation of Certificate objects

    Replacement for most parts of CertificateManager's parse and validate methods.
    Skips field 'editing' as unused, delegates id assigning to Certificate class.
    """
    version = serializers.CharField(required=True, allow_blank=False)
    id = serializers.IntegerField(required=False)
    name = serializers.CharField(required=True, allow_blank=False)
    description = serializers.CharField(required=True, allow_blank=True)
    is_active = serializers.BooleanField(required=False, default=False)

    course_title = serializers.CharField(required=False, allow_blank=True)
    course_description = serializers.CharField(required=False, allow_blank=True)

    show_grade = serializers.BooleanField(required=False, default=False)
    honor_code_disclaimer = serializers.CharField(required=False, allow_blank=True)

    organizations = OrganizationSerializer(required=False, many=True, default=list)
    signatories = SignatorySerializer(required=False, many=True, default=list)

    def validate_version(self, value):
        """
        Ensure the schema version meets our expectations
        """
        if value != CERTIFICATE_SCHEMA_VERSION:
            raise serializers.ValidationError(
                "Unsupported certificate schema version: {0}.  Expected version: {1}.".format(
                    value, CERTIFICATE_SCHEMA_VERSION
                )
            )
        return value


class CertificateManager(object):
    """
    The CertificateManager is responsible for storage, retrieval, and manipulation of Certificates
    Certificates are not stored in the Django ORM, they are a field/setting on the course descriptor
    """

    @staticmethod
    def serialize_certificate(certificate):
        """
        Serialize the Certificate object's locally-stored certificate data to a JSON representation
        """
        certificate_data = certificate.certificate_data
        certificate_data["version"] = CERTIFICATE_SCHEMA_VERSION
        assert all(
            field in certificate_data
            for field in ('id', 'name', 'description', 'is_active', 'show_grade', 'version')
        )
        return certificate_data

    @staticmethod
    def deserialize_certificate(course, value):
        """
        Deserialize from a JSON representation into a Certificate object.
        'value' should be either a Certificate instance, or a valid JSON string
        """
        try:
            raw_data = json.loads(value)
        except ValueError:
            raise CertificateValidationError(_("invalid JSON"))

        serializer = CertificateSerializer(data=raw_data)
        if serializer.is_valid():
            certificate_data = serializer.data
            certificate = Certificate(course, certificate_data)
            return certificate
        else:
            error_str = ' '.join(u'{}: {}'.format(key, val[0]) for key, val in serializer.errors.items())
            raise CertificateValidationError(error_str)

    @staticmethod
    def get_certificates(course, only_active=False):
        """
        Retrieve the certificates list from the provided course,
        if `only_active` is True it would skip inactive certificates.
        """
        # The top-level course field is 'certificates', which contains various properties,
        # including the actual 'certificates' list that we're working with in this context
        certificates = course.certificates.get('certificates', [])
        if only_active:
            certificates = [certificate for certificate in certificates if certificate.get('is_active', False)]
        return certificates

    @staticmethod
    def remove_certificate(request, store, course, certificate_id):
        """
        Remove certificate from the course
        """
        for index, cert in enumerate(course.certificates['certificates']):
            if int(cert['id']) == int(certificate_id):
                certificate = course.certificates['certificates'][index]
                # Remove any signatory assets prior to dropping the entire cert record from the course
                for sig_index, signatory in enumerate(certificate.get('signatories')):  # pylint: disable=unused-variable
                    _delete_asset(course.id, signatory['signature_image_path'])
                # Now drop the certificate record
                course.certificates['certificates'].pop(index)
                store.update_item(course, request.user.id)
                break

    # pylint-disable: unused-variable
    @staticmethod
    def remove_signatory(request, store, course, certificate_id, signatory_id):
        """
        Remove the specified signatory from the provided course certificate
        """
        for cert_index, cert in enumerate(course.certificates['certificates']):  # pylint: disable=unused-variable
            if int(cert['id']) == int(certificate_id):
                for sig_index, signatory in enumerate(cert.get('signatories')):  # pylint: disable=unused-variable
                    if int(signatory_id) == int(signatory['id']):
                        _delete_asset(course.id, signatory['signature_image_path'])
                        del cert['signatories'][sig_index]
                        store.update_item(course, request.user.id)
                        break

    @staticmethod
    def track_event(event_name, event_data):
        """Track certificate configuration event.

        Arguments:
            event_name (str):  Name of the event to be logged.
            event_data (dict): A Dictionary containing event data
        Returns:
            None

        """
        event_name = '.'.join(['edx', 'certificate', 'configuration', event_name])
        tracker.emit(event_name, event_data)


class Certificate(object):
    """
    The logical representation of an individual course certificate
    """
    def __init__(self, course, certificate_data):
        """
        Instantiate a Certificate object instance using the provided information.
        """
        self.course = course
        self._certificate_data = certificate_data
        self.assign_missing_ids()
        self.id = certificate_data['id']  # pylint: disable=invalid-name

    def assign_missing_ids(self):
        """
        Assign an identifier to the certificate data if required.
        If identifier is not provided, we autogenerate a unique one for them
        In addition, we check the certificate's signatories and ensure they also have unique ids
        """
        used_ids = Certificate.get_used_ids(self.course)
        certificate_id = self._certificate_data.get('id')
        if certificate_id:
            self._certificate_data['id'] = int(certificate_id)
        else:
            self._certificate_data['id'] = generate_int_id(
                CERTIFICATE_MINIMUM_ID,
                MYSQL_MAX_INT,
                used_ids
            )

        for signatory in self._certificate_data['signatories']:  # pylint: disable=unused-variable
            if signatory and not signatory.get('id', False):
                signatory['id'] = generate_int_id(used_ids=used_ids)
            used_ids.append(signatory['id'])

    @staticmethod
    def get_used_ids(course):
        """
        Return a list of certificate identifiers that are already in use for this course
        """
        if not course.certificates or not course.certificates.get('certificates'):
            return []
        return [cert['id'] for cert in course.certificates['certificates']]

    @property
    def certificate_data(self):
        """
        Retrieve the locally-stored certificate data from the Certificate object via a helper method
        """
        return self._certificate_data


@login_required
@require_http_methods(("POST",))
@ensure_csrf_cookie
def certificate_activation_handler(request, course_key_string):
    """
    A handler for Certificate Activation/Deactivation

    POST
        json: is_active. update the activation state of certificate
    """
    # Only global staff (PMs) are able to activate/deactivate certificate configuration
    if not GlobalStaff().has_user(request.user):
        raise PermissionDenied()
    course_key = CourseKey.from_string(course_key_string)
    store = modulestore()
    try:
        course = _get_course_and_check_access(course_key, request.user)
    except PermissionDenied:
        msg = _('PermissionDenied: Failed in authenticating {user}').format(user=request.user)
        return JsonResponse({"error": msg}, status=403)

    data = json.loads(request.body)
    is_active = data.get('is_active', False)
    certificates = CertificateManager.get_certificates(course)

    # for certificate activation/deactivation, we are assuming one certificate in certificates collection.
    for certificate in certificates:
        certificate['is_active'] = is_active
        break

    store.update_item(course, request.user.id)
    cert_event_type = 'activated' if is_active else 'deactivated'
    CertificateManager.track_event(cert_event_type, {
        'course_id': unicode(course.id),
    })
    return HttpResponse(status=200)


@login_required
@require_http_methods(("GET", "POST"))
@ensure_csrf_cookie
def certificates_list_handler(request, course_key_string):
    """
    A RESTful handler for Course Certificates

    GET
        html: return Certificates list page (Backbone application)
    POST
        json: create new Certificate
    """
    course_key = CourseKey.from_string(course_key_string)
    store = modulestore()
    with store.bulk_operations(course_key):
        try:
            course = _get_course_and_check_access(course_key, request.user)
        except PermissionDenied:
            msg = _('PermissionDenied: Failed in authenticating {user}').format(user=request.user)
            return JsonResponse({"error": msg}, status=403)

        if 'text/html' in request.META.get('HTTP_ACCEPT', 'text/html'):
            certificate_url = reverse_course_url('certificates.certificates_list_handler', course_key)
            course_outline_url = reverse_course_url('course_handler', course_key)
            upload_asset_url = reverse_course_url('assets_handler', course_key)
            activation_handler_url = reverse_course_url(
                handler_name='certificates.certificate_activation_handler',
                course_key=course_key
            )
            course_modes = [mode.slug for mode in CourseMode.modes_for_course(
                course_id=course.id, include_expired=True
            )]
            certificate_web_view_url = get_lms_link_for_certificate_web_view(
                user_id=request.user.id,
                course_key=course_key,
                mode=course_modes[0]  # CourseMode.modes_for_course returns default mode 'honor' if doesn't find anyone.
            )
            certificates = None
            is_active = False
            if settings.FEATURES.get('CERTIFICATES_HTML_VIEW', False):
                certificates = CertificateManager.get_certificates(course)
                # we are assuming only one certificate in certificates collection.
                for certificate in certificates:
                    is_active = certificate.get('is_active', False)
                    break

            organizations_list = get_serializable_organizations_list()
            default_organizations = get_default_certificate_organizations(course_key)

            return render_to_response('certificates.html', {
                'context_course': course,
                'certificate_url': certificate_url,
                'course_outline_url': course_outline_url,
                'upload_asset_url': upload_asset_url,
                'certificates': certificates,
                'course_modes': course_modes,
                'certificate_web_view_url': certificate_web_view_url,
                'is_active': is_active,
                'is_global_staff': GlobalStaff().has_user(request.user),
                'certificate_activation_handler_url': activation_handler_url,
                'organizations_list': organizations_list,
                'default_organizations': default_organizations
            })
        elif "application/json" in request.META.get('HTTP_ACCEPT'):
            # Retrieve the list of certificates for the specified course
            if request.method == 'GET':
                certificates = CertificateManager.get_certificates(course)
                return JsonResponse(certificates, encoder=EdxJSONEncoder)
            elif request.method == 'POST':
                # Add a new certificate to the specified course
                try:
                    new_certificate = CertificateManager.deserialize_certificate(course, request.body)
                except CertificateValidationError as err:
                    return JsonResponse({"error": err.message}, status=400)
                if course.certificates.get('certificates') is None:
                    course.certificates['certificates'] = []
                course.certificates['certificates'].append(new_certificate.certificate_data)
                response = JsonResponse(CertificateManager.serialize_certificate(new_certificate), status=201)
                response["Location"] = reverse_course_url(
                    'certificates.certificates_detail_handler',
                    course.id,
                    kwargs={'certificate_id': new_certificate.id}
                )
                store.update_item(course, request.user.id)
                CertificateManager.track_event('created', {
                    'course_id': unicode(course.id),
                    'configuration_id': new_certificate.id
                })
                course = _get_course_and_check_access(course_key, request.user)
                return response
        else:
            return HttpResponse(status=406)


@login_required
@ensure_csrf_cookie
@require_http_methods(("POST", "PUT", "DELETE"))
def certificates_detail_handler(request, course_key_string, certificate_id):
    """
    JSON API endpoint for manipulating a course certificate via its internal identifier.
    Utilized by the Backbone.js 'certificates' application model

    POST or PUT
        json: update the specified certificate based on provided information
    DELETE
        json: remove the specified certificate from the course
    """
    course_key = CourseKey.from_string(course_key_string)
    course = _get_course_and_check_access(course_key, request.user)

    certificates_list = course.certificates.get('certificates', [])
    match_index = None
    match_cert = None
    for index, cert in enumerate(certificates_list):
        if certificate_id is not None:
            if int(cert['id']) == int(certificate_id):
                match_index = index
                match_cert = cert

    store = modulestore()
    if request.method in ('POST', 'PUT'):
        if certificate_id:
            active_certificates = CertificateManager.get_certificates(course, only_active=True)
            if int(certificate_id) in [int(certificate["id"]) for certificate in active_certificates]:
                # Only global staff (PMs) are able to edit active certificate configuration
                if not GlobalStaff().has_user(request.user):
                    raise PermissionDenied()
        try:
            new_certificate = CertificateManager.deserialize_certificate(course, request.body)
        except CertificateValidationError as err:
            return JsonResponse({"error": err.message}, status=400)

        serialized_certificate = CertificateManager.serialize_certificate(new_certificate)
        cert_event_type = 'created'
        if match_cert:
            cert_event_type = 'modified'
            certificates_list[match_index] = serialized_certificate
        else:
            certificates_list.append(serialized_certificate)

        store.update_item(course, request.user.id)
        CertificateManager.track_event(cert_event_type, {
            'course_id': unicode(course.id),
            'configuration_id': serialized_certificate["id"]
        })
        return JsonResponse(serialized_certificate, status=201)

    elif request.method == "DELETE":
        if not match_cert:
            return JsonResponse(status=404)

        active_certificates = CertificateManager.get_certificates(course, only_active=True)
        if int(certificate_id) in [int(certificate["id"]) for certificate in active_certificates]:
            # Only global staff (PMs) are able to delete active certificate configuration
            if not GlobalStaff().has_user(request.user):
                raise PermissionDenied()

        CertificateManager.remove_certificate(
            request=request,
            store=store,
            course=course,
            certificate_id=certificate_id
        )
        CertificateManager.track_event('deleted', {
            'course_id': unicode(course.id),
            'configuration_id': certificate_id
        })
        return JsonResponse(status=204)


@login_required
@ensure_csrf_cookie
@require_http_methods(("POST", "PUT", "DELETE"))
def signatory_detail_handler(request, course_key_string, certificate_id, signatory_id):
    """
    JSON API endpoint for manipulating a specific course certificate signatory via its internal identifier.
    Utilized by the Backbone 'certificates' application.

    DELETE
        json: Remove the specified signatory from the specified certificate
    """
    course_key = CourseKey.from_string(course_key_string)
    store = modulestore()
    with store.bulk_operations(course_key):
        course = _get_course_and_check_access(course_key, request.user)
        certificates_list = course.certificates['certificates']

        match_cert = None
        # pylint: disable=unused-variable
        for index, cert in enumerate(certificates_list):
            if certificate_id is not None:
                if int(cert['id']) == int(certificate_id):
                    match_cert = cert

        if request.method == "DELETE":
            if not match_cert:
                return JsonResponse(status=404)
            CertificateManager.remove_signatory(
                request=request,
                store=store,
                course=course,
                certificate_id=certificate_id,
                signatory_id=signatory_id
            )
            return JsonResponse(status=204)
